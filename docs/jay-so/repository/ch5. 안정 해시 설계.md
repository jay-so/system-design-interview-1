# 5️⃣  안정 해시 설계

---

## 개요

---

- 수평적 규모 확장성을 달성하기 위해서는 요청 또는 데이터를 서버에 균등하게 나누는 것이 중요함


### 🎯 안정 해시 
- 수평적 규모 확장을 위해, 요청 또는 데이터를 서버에 균등하게 나누기 위해 보편적으로 사용하는 기술임


## 해시 키 재배치 문제

---

**예시**
- N개의 캐시 서버가 존재함

-> 해당 서버에 부하를 균등하게 나누는 보편적인 방법은 다음의 해시 함수를 사용함

``` text
serverIndex = hash(key) % N
(N = 서버의 갯수)
```


+) 서버 인덱스란?
- 특정 데이터를 저장하거나 조회할 때 어떤 서버에 접근하기 하는지를 결정하기 위해 사용하는 서버의 고유번호나 식별자를 의미함
- 해당 부분에서 서버는 캐시를 의미함


**예시**
- 총 4대의 서버를 사용할 경우


**주어진 각각의 키에 대해서 해시 값과 서버 인덱스를 계산한 결과**
- 특정한 키가 보관된 서버를 알아내기 위해, 다음과 같이 해시함수를 이용함

``` text
serverIndex = hash(key) %4를 사용한다고 가정할 때
hash(key0) % 4 = 1이면, 클라이언트는 캐시에 보관된 데이터를 가져오기 위해 서버 1에 접속해야 함
```


![1.png](..%2F..%2F..%2Fimages%2Fjay-so%2F5%EC%9E%A5%2F1.png)


**예시**
- **키 값이 서버에 분산된 예**
- 서버 풀의 크기가 고정되어 있을 때, 데이터 분포가 균등할 때는 잘 작동함
  - 하지만, 서버가 추가되거나 기존 서버가 삭제되면 문제가 발생함
  **- 1번 서버의 장애 발생 -> 서버 풀의 크기가 3으로 변동됨**


![2.png](..%2F..%2F..%2Fimages%2Fjay-so%2F5%EC%9E%A5%2F2.png)


+) 서버 풀(server pool) = 네트워크 상에 서비스를 제공하기 위해 사용되는 서버들의 집합을 의미함
+) 서버 풀이 고정되어 있음 = 서비스를 젝ㅇ하기 위해 사용되는 서버의 수가 일정함


**1번 서버에 장애가 발생되어 서버 풀의 크기가 3으로 변동될 경우**
- hash(key) % 3의 결과 값

![3.png](..%2F..%2F..%2Fimages%2Fjay-so%2F5%EC%9E%A5%2F3.png)


### 변화된 키의 분포
- 장애가 발생된 1번 서버에 보관되어 있는 키뿐만 아닌, 대부분의 키가 재분배됨

=> 1번 서버가 죽으면, 대부분의 캐시 클라이언트가 데이터가 없는 엉뚱한 서버에 접속하게 됨

=> 대규모 캐시 미스가 발생됨

=> **안정 해시는 해당 문제를 효과적으로 해결함**


![4.png](..%2F..%2F..%2Fimages%2Fjay-so%2F5%EC%9E%A5%2F4.png)


## 안정 해시

---

안정 해시 = 해시 테이블의 크기가 조정될 때, 평균적으로 오직 K/N개의 키만 재배치하는 해시 기술임
- K = 키의 갯수, N = 슬롯(slot)의 갯수
<-> 전통적인 해시 테이블 = 슬롯의 수가 변경되면, 대부분의 키를 재배치함


**+)전통적인 해시 테이블의 슬롯 숫자를 변경되면, 키를 재배치하는 과정**
1. 슬롯 수 변경: 해시 테이블의 크기가 증가하거나 감소하면, 새로운 슬롯 수에 맞게 해시 테이블의 구조를 조정해야 합니다. 이는 보통 해시 테이블을 확장하거나 축소할 때 발생함
2. 해시 함수 재적용: 새로운 슬롯 수에 대해 모든 키에 대해 해시 함수를 다시 적용합니다. 해시 함수는 키를 입력으로 받아서, 해당 키가 저장될 해시 테이블 내의 슬롯(인덱스)를 결정합니다. 슬롯의 수가 변경되면, 해시 함수의 결과값(즉, 키가 배치될 위치)도 변경될 수 있음
3. 키의 재배치: 해시 함수를 다시 적용한 결과, 각 키는 새로운 슬롯에 배치됩니다. 이 과정에서 대부분의 키들이 기존 위치에서 다른 위치로 이동하게 됩니다. 즉, 새로운 해시 테이블 구조에 맞춰 키들이 재배치함
4. 충돌 해결: 해시 테이블의 크기가 변경되면서 새로운 충돌이 발생할 수 있습니다. 따라서, 재배치 과정에서 충돌 해결 방식(예: 체이닝, 개방 주소법 등)을 적절히 적용하여 키들을 재배함

https://study-ihl.tistory.com/71

**+) 안정 해시는 어디에서 사용하는가?**
1. 분산 캐싱: 분산 캐싱 시스템에서, 데이터를 여러 캐시 서버에 분산하여 저장합니다. 안정 해시를 사용하면 캐시 서버가 추가되거나 제거될 때 전체 키를 재배치하지 않아도 되므로, 캐싱 효율성을 높이고 네트워크 오버헤드를 줄일 수 있습니다.
2. 로드 밸런싱: 웹 서비스나 애플리케이션의 로드 밸런서에서 안정 해시를 사용하여 요청을 여러 서버에 균등하게 분배할 수 있습니다. 서버의 추가 또는 제거 시에도 대부분의 요청이 기존의 서버로 유지되어 전체 시스템의 안정성을 보장합니다.
3. 분산 데이터베이스: 분산 데이터베이스 시스템에서 데이터를 여러 노드에 분산하여 저장할 때, 안정 해시를 이용하면 데이터의 위치를 효과적으로 결정하고, 노드의 추가나 제거에 따른 데이터 재배치 비용을 최소화할 수 있습니다.
4. P2P 네트워크: P2P(Peer-to-Peer) 네트워크에서는 안정 해시를 사용하여 각 피어(노드)가 담당하는 데이터 영역을 결정합니다. 이를 통해 네트워크 내에서 피어의 추가나 제거가 이루어져도 전체 시스템의 데이터 접근성과 안정성을 유지할 수 있습니다.

https://willseungh0.tistory.com/174


### 해시 공간과 해시 링

**안정 해시의 동작원리**
- 해시 함수 F로 SHA-1을 사용하며, 해당 함수의 출력 값의 범위는 x0,x1,...xN과 같다고 가정
- SHA-1 해시 공간의 범위 = 2^160 -1이며, 나머지 x1~xN-1까지는 해당 사이의 값을 갖게 됨


**해시 공간을 그림으로 표현한 예** 
![5.png](..%2F..%2F..%2Fimages%2Fjay-so%2F5%EC%9E%A5%2F5.png)


**해시 공간의 양쪽을 구부려 접으면, 다음가 같은 해시 링이 생성됨**
![6.png](..%2F..%2F..%2Fimages%2Fjay-so%2F5%EC%9E%A5%2F6.png)


**+)SHA-1**
- SHA-1은 SHA-0을 변형한 SHA 함수들 중 하나이며, 1995년 발표되었고 SHA 함수들 중 가장 많이 쓰이고 있습니다.
- SHA-1은 임의의 길이의 입력데이터 (최대 2⁶⁴)를 160비트의 출력데이터(해시값)로 바꿉니다.
- 로널드 라이베스트(Ronald Lorin Rivest)가 MD4 및 MD5 해시 함수에서 사용했던 것과 비슷한 방법을 사용합니다.
- 위의 그림은 SHA-1 압축 함수가 블록 하나를 처리하는 과정입니다. 그림에서 A, B, C, D, E는 각각 32비트 내부 상태이고, F는 계속 변하는 비선형 함수이며, Kt는 상수입니다. 또한 n은 n비트만큼 왼쪽으로 회전하는 연산이고, 사각형 네개를 붙인 모양은 2³² 모듈로 덧셈을 나타냅니다

https://velog.io/@ejjjang0414/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-SHA-1-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80


### 해시 서버
- 해당 해시 함수 f를 사용하여 서버 IP나 이름을 해당 링 위에 어떤 위치에 대응할 수 있음
-> 해시 링 위에 해시 함수 f를 사용하여 서버의 ip나 이름을 해당 해시 링 위에 어떤 위치에 대응할 수 있음을 의미함


**4개의 서버를 해당 해시 링 위에 배치한 예시**

![7.png](..%2F..%2F..%2Fimages%2Fjay-so%2F5%EC%9E%A5%2F7.png)


### 해시 키

- 해시 키 는 해시 링의 해시 함수에 의해 자리가 지정됨

**예시**
- 해당 부분에서 사용한 해시함수는 이전의 해시 %4와 다른 임의의 해시 함수를 사용한 예임

![8.png](..%2F..%2F..%2Fimages%2Fjay-so%2F5%EC%9E%A5%2F8.png)

### 서버 조회
- 어떤 키가 저장되는 서버는, 해당 키의 위치로 시계 방향으로 링을 탐색해 나가면서 만나는 첫번째 서비스를 의미함
- key0는 서버 0에 저장되며, Key1은 서버 1에 저장됨
- key2는 서버 2, key3는 서버 3에 저장됨

![9.png](..%2F..%2F..%2Fimages%2Fjay-so%2F5%EC%9E%A5%2F9.png)

### 서버 추가
- 서버를 추가하더라도, 키 가운데 일부만 재배치하면 됨


**예시**
- 새로운 서버 4가 추가된 후, Key0만 재배치됨
- k1,k2,k3는 같은 서버에 남음


**서버 4가 추가되지 전**
- key0는 서버 0에 저장되어 있음
- 하지만 서버4가 추가된 디, Key0는 서버4에 저장됨
- key0의 위치에서 시계 방향으로 조회했을 때 처음 만나게 되는 서버가 4이기 때문(나머지 키들은 재배치 되지 않음)

![10.png](..%2F..%2F..%2Fimages%2Fjay-so%2F5%EC%9E%A5%2F10.png)

### 서버 제거
- 하나의 서버가 제거되면, 키 가운데 일부만 재배치됨

**예시**
- 서버1이 삭제되었을 때, key1만 서버2로 재배치됨
- 나머지 키들은 영향이 없음

![11.png](..%2F..%2F..%2Fimages%2Fjay-so%2F5%EC%9E%A5%2F11.png)


### 기존 구현법의 2가지 문제점

안정 해시 알고리즘의 절차
1. 서버와 키를 균등 분포 해시 함수를 사용하여 해시 링에 배치함
2. 키의 위치와 링을 시계 방향으로 탐색하다가 만나는 최초의 서버가 키가 저장될 서버임


**해당 접근법의 문제점**
1. 서버가 추가되거나, 삭제되는 상황을 감안하면 파티션의 크기를 균등하게 유지하는 것은 불가능함
- 파티션 = 인접한 서버 사이의 해시 공간
- 어떤 서버는 굉장히 작은 해시 공간을 할당 받고, 어떤 서버는 굉장히 큰 해시 공간을 할당 받는 상황이 가능함


**예시**
- s1이 삭제되어 s2의 파티션이 다른 파티션 대비 거의 2배로 커지는 상황

![12.png](..%2F..%2F..%2Fimages%2Fjay-so%2F5%EC%9E%A5%2F12.png)


2. 키의 균등 분포를 달성하기 어려움


**예시**
- 서버1과 서버3은 아무 데이터를 갖지 않은 반면, 대부분의 키는 서버 2에 보관됨
![13.png](..%2F..%2F..%2Fimages%2Fjay-so%2F5%EC%9E%A5%2F13.png)


-> 해당 문제를 해결하기 위해 제안된 방법 = 가상노드, 복제 노드

+) 참고 자료
https://binux.tistory.com/119

### 가상 노드
- 가상 노드 = 실제 노드 or 서버를 가리키는 노드로써, 1개의 서버는 링 위에 여러 개의 가상 노드를 가질 수 있음

**예시**
- 서버 0과 서버1은 3개의 가상 노드를 가짐
- 실제 시스템에서는 해당 값(3개)보다 훨씬 더 큰 값을 사용하게 됨
- 서버 0을 링에 배치하기 위해 s0 하나만 사용하는 대신, s0_0,s0_1,s0_2의 3개의 가상 노드를 사용함
- 서버 1을 링에 배치할 때는 s1 하나 대신 s1_0,s1_1,s1_2의 3개의 가상 노드를 사용함
**-> 따라서 각각의 서버는 하나가 아닌 여러 개의 파티션을 관리해야 함**
**-> s0으로 표시된 파티션 = 서버 0이 관리하는 파티션**
**-> s1으로 표시된 파티션 = 서버1이 관리하는 파티션**


키의 위치로부터 시계방향으로 링을 탐색하다 만나는 최초의 가상 노드 = 해당 키가 저장될 서버임


![14.png](..%2F..%2F..%2Fimages%2Fjay-so%2F5%EC%9E%A5%2F14.png)


**예시**
- k0가 저장되는 서버 = k0의 위치로부터 링을 시계 방향으로 탐색하다가 만나는 최초의 가상 노드 s1_1가 나타내는 서버, 즉 서버1임

![15.png](..%2F..%2F..%2Fimages%2Fjay-so%2F5%EC%9E%A5%2F15.png)


가상 노드의 갯수를 늘리면, 키의 분포는 점점 더 균등해짐
- 표준 편차가 작아져 데이터가 고르게 분포되기 때문
- 표준 편차 = 데이터가 어떻게 퍼져 나갔는지를 보이는 척도


**예시**
- 100~200개의 가상 노드를 사용할 경우
- 평균의 5%(가상 노드가 200개인 경우)에서 10%(가상 노드가 100개인 경우)사이임
- 가상 노드의 갯수를 더 늘리면, 표준 편차의 값은 더 크게 떨어짐

**→ 그러나, 가상 노드 데이터를 저장할 공간은 더 많이 필요하게 됨**

**→ 시스템의 요구사항에 맞도록 가상 노드 갯수를 적절히 조정해야 함**


### 재배치할 키 결정
- 서버가 추가되거나 제거되면, 데이터의 일부는 재배치해야 함


**예시**
- 서버 4가 추가되었다고 가정함
- **이에 영향을 받은 범위는 s4(새로운 노드)부터, 반시계 방향에 있는 첫번째 서버 s3까지임**

**→ s3부터 s4 사이에 있는 키들을 s4로 재배치해야 함**
![16.png](..%2F..%2F..%2Fimages%2Fjay-so%2F5%EC%9E%A5%2F16.png)


- **서버 s1이 다음과 같이 삭제됨**


**→ s1(삭제된 노드)부터 그 반시계 방향에 있는 최초 서버 s0 사이에 있는 키들이 s2로 재배치되어야 함**
![17.png](..%2F..%2F..%2Fimages%2Fjay-so%2F5%EC%9E%A5%2F17.png)


## 마치며

---

### 안정 해시의 장점
1. 서버가 추가되거나, 삭제될 때 재배치되는 키의 수가 최소화됨
2. 데이터가 보다 균등하게 분포하게 되므로 수평적 규모 확장을 달성하기 쉬움
3. 핫스팟(hotspot) 키 문제를 줄임

+) 핫스팟 키 문제
```text
특정 키(데이터)에 대한 접근 빈도가 다른 키들에 비해 현저하게 높아, 
해당 키가 저장된 서버에 과부하가 집중되는 현상을 의미함
```


4. 특정한 샤드에 대한 접근이 지나치게 빈번하면 서버 과부화 문제가 생길 수 있음
   - 특정 유명인의 데이터가 전부 같은 몰리는 상황과 유사함
   - 안정 해시는 데이터를 좀 더 균등하게 분배함으로, 해당 문제가 생길 가능성을 줄임

**-> 안정 해시는 실제로 널리 사용되는 기술임**


**예시**
- 아마존 다이나모 데이터베이스의 파티셔닝 관련 컴포넌트
- 아파치 카산드라 클러스터에서의 데이터 파티셔닝
- 디스코드 채팅 어플리케이션
- 아마카이 CDN
- 매그레프 네트워크 부하 분산기

+) 참고자료
https://loosie.tistory.com/820
