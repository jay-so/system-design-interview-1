# 4️⃣ 처리율 제한 장치의 설계_part1

---

## 3️⃣ 상세 설계

- 개략적 설계만 봐서는 다음과 같은 사항들은 알 수가 없습니다.
1. 처리율 제한 규칙은 어떻게 만들어지고, 어디에 저장되는가?
2. 처리가 제한된 요청들은 어떻게 처리되는가?

- 이를 위해 상세적인 설계가 필요합니다.


### 처리율 제한 규칙
- 리프트는 처리율 제한에 오픈소스를 사용하고 있습니다. 해당 컴포넌트들을 보고, 어떤 처리율 제한 조건 규칙이 사용되고 있는지 살펴봅시다.

**시스템이 처리할 수 있는 마케팅 메시지의 최대치를 하루 5개로 제한하고 있는 예시**

``` text
domain: messaging
descrptor:
 - key: message_type
   Value: marketing
   rate_limit:
       unit: day
       requests _per_unit: 5
```


**클라이언트가 분당 5회 이상 로그인 할 수 없게한 사례**
``` text
domain: messaging
descrptor:
 - key: message_type
   Value: marketing
   rate_limit:
       unit: minute
       requests _per_unit: 5
```


- 보통 이런 규칙들은 설정파일(configuration file)형태로 디스크에 저장됩니다.

### 처리율 한도 초과 트래픽 처리
- 어떤 요청이 한도 제한에 걸리면 API는 HTTP 429 응답을 클라이언트에게 보냅니다.
- 경우에 따라서는, 한도 제한에 걸린 메시지를 나중에 처리하기 위해 큐에 보관할 수도 있습니다.


#### 처리율 제한 장치가 사용하는 HTTP 헤더
- 클라이언트는 자기 요청이 처리율 제한에 걸리고 있는지를 어떻게 감지할 수 있을까요?
- 또한, 자기 요청이 처리율 제한에 걸리기까지 얼마나 많은 요청을 보낼 수 있는지 어떻게 알 수 있을까요?
- 해당 답은 HTTP 응답 헤더에 있습니다.
- 처리율 제한 장치는 다음의 HTTP 헤더를 클라이언트에게 보냅니다.


1. X-Ratelimit-Remaining: 윈도 내에 남은 처리 가능 요청의 수
2. X-Ratelimit-Limit: 매 윈도마다 클라이언트가 전송할 수 있는 요청의 수
3. X-Ratelimit-Retry-After:한도 제한에 걸리지 않으려면 몇 초 뒤에 요청을 다시 보내야 하는지 알림

- 사용자가 너무 많은 요청을 보내면 429 too many requests 오류를 X-Ratelimit-Retry-After 헤더와 함께 반환합니다.


### 상세 설계

![13.png](..%2F..%2F..%2Fimages%2Fjay-so%2F4%EC%9E%A5%2F13.png)


- 처리율 제한 규칙은 디스크에 보관합니다. 작업 프로세스는 수시로 규칙을 디스크에서 읽어 캐시에 저장합니다.
- 클라이언트가 요청을 서버에 보내면, 요청은 먼저 처리율 제한 미들웨어에 도달합니다.
- 처리율 제한 미들웨어는 제한 규칙을 캐시에서 가져옵니다. 아울러 카운터 및 마지막 요청의 타임 스탬프를 레디스 캐시에서 가져옵니다. 가져온 값들에 근거하여 해당 미들웨어는 다음과 같은 결정을 내립니다.
  - 해당 요청이 처리율 제한에 걸리지 않은 경우에는 API서버로 보냅니다.
  - 해당 요청이 처리율 제한에 걸렸다면 429 too many requests 에러를 클라이언트에게 보냅니다.
  - 한편 해당 요청은 그대로 버릴 수도 있고, 메시지 큐에 보관할 수도 있습니다.

    
### 분산 환경에서의 처리율 제한 장치의 구현
- 단일 서버를 지원하는 처리율 제한 장치를 구현하는 것은 어렵지 않습니다.
- 하지만 여러 서버와 병렬 스레드를 지원하도록 시스템을 확장하는 것은 또 다른 문제입니다.
- 다음의 2가지 어려운 문제를 해결해야 합니다.


### 경쟁 조건
- 처리율 제한 장치는 다음과 같이 동작합니다.
1. 레디스에서 카운터의 값을 읽는다.(counter)
2. counter + 1의 값이 임계치를 넘는지 살펴봅니다.
3. 넘지 않는다면, 레디스에 보관된 카운터 값을 1만큼 증가시킵니다.

- 병행성이 심한 환경에서는 다음과 같이 경쟁 조건 이슈가 발생할 수 있습니다.

![14.png](..%2F..%2F..%2Fimages%2Fjay-so%2F4%EC%9E%A5%2F14.png)

레디스에 저장된 변수 counter의 값이 3이라고 가정합시다.
그리고, 2개 요청을 처리하는 스레드가 각각 병렬로 counter 값을 읽었으며, 그 둘 가운데 어느쪽도 아직 변경된 값을 저장하지 않은 상태라고 가정합시다.
- 서로 다른 두 요청의 처리 상태는 상관하지 않고, counter에 1을 더한 값을 레디스에 기록할 것입니다.
- 그리고 counter의 값은 올바르게 변경되었다고 믿을 것입니다.
- 그러나 사실 counter의 값은 5가 되어야 하며, 해당 경쟁 조건 문제를 해결하기 위해 보통 락을 사용합니다.
- 하지만 락은 시스템의 성능을 상당히 떨어트린다는 문제가 있습니다.
- 위의 경우, 락 대신 사용할 수 있는 해결책은 다음과 같이 2가지가 있습니다.

#### 👉🏻  해결책
1. 하나는 루아 스크립트
2. 정렬 집합이라고 부르는 레디스 자료구조 sorted set을 사용


### 동기화 이슈
- 동기화는 분산 환경에서 고려해야 할 중요한 요소입니다.
- 수백만 사용자를 지원하려면, 한대의 처리율 제한 장치 서버로는 충분하지 않을 수도 있습니다.
- 그래서 처리율 제한 장치 서버를 여러 대 두게 되면 동기화가 필요해집니다.
- 하지만, 웹 계층은 무상태이므로 클라이언트는 다음 요청을 오른쪽 그림처럼 각기 다른 제한 장치로 보내게 될 수 있습니다.
- 이때, 동기화를 하지 않는다면 제한 장치1은 클라이언트 2에 대해서 아무것도 모르고 처리율 제한을 올바르게 수행할 수 밖에 없을 것입니다.

![15.png](..%2F..%2F..%2Fimages%2Fjay-so%2F4%EC%9E%A5%2F15.png)

#### 👉🏻  해결책
1. 고정 세션을 활용하여, 같은 클라이언트로부터의 요청은 항상 같은 처리율 제한 장치로 보낼 수 있도록 합니다.
- 해당 방법은 추천하지 않는데, 규모면에서 확장이 가능하지도 않고 유연하지도 않기 때문입니다.
2. 레디스와 같은 중앙 집중형 데이터 저장소를 사용하는 것입니다.

![16.png](..%2F..%2F..%2Fimages%2Fjay-so%2F4%EC%9E%A5%2F16.png)


### 성능 최적화
- 지금까지의 설계에서는 2가지 지점에서 개선이 가능합니다.

1. 엣지 서버를 통해 지연시간을 최소화
- 데이터센터에서 멀리 떨어진 사용자를 지원하려다가 보면, 지연시간이 증가할 수 밖에 없기 때문입니다.
- 이에, 대부분의 클라우드 서비스 사업자는 세계 곳곳에 엣지 서버를 두어, 지연시간을 최소화시킵니다.

2. 제한 장치간에 데이터를 동기화할때, 최종 일관성 모델을 사용하는 것
- "키 - 값 저장소 설계"를 통해 제한 장치 간의 데이터의 일관성을 유지시킵니다.


### 모니터링
- 처리율 제한 장치를 설치한 이후에는 효과적으로 동작하고 있는지 보기 위해, 데이터를 모을 필요가 있습니다.
- 기본적으로 모니터링을 통해 확인하려고 하는 것은 다음 2가지 입니다.

1. 채택된 처리율 제한 알고리즘이 효과적이다.
2. 정의한 처리율 제한 규칙이 효과적이다.


- 예를 들어 처리율 제한 규칙이 너무 빡빡하게 설정되었다면, 많은 유효 요청이 처리되지 못하고 버려질 것입니다.
- 그런 일이 벌어진다면 규칙을 다소 완화할 필요가 있습니다.
- 깜짝 세일 같은 이벤트 때문에 트래픽이 급증할 때, 처리율 제한 장치가 비효율적으로 동작한다면, 그런 트래픽 패턴을 잘 처리할 수 있도록 알고리즘을 바꾸는 것을 생각해봐야 합니다.


## 4️⃣ 마무리

- 해당 4장에서 다룬 알고리즘
1. 토큰 버킷
2. 누출 버킷
3. 고정 윈도 카운터
4. 이동 윈도 로그
5. 이동 윈도 카운터


- 경성(hard) 또는 연성(soft) 처리율 제한
  - 경성 처리율 제한: 요청의 개수는 임계치를 절대 넘어설 수 없습니다.
  - 연성 처리율 제한: 요청의 개수느느 잠시 동안은 임계치를 넘어설 수 있습니다.


- 다양한 계층에서의 처리율 제한
  - 해당 4장에서는 애플리케이션 계층(HTTP)에서의 처리율 제한에서만 살펴보았습니다.
  - 하지만 다른 계층에서도 처리율 제한이 가능합니다.
    - Iptables을 사용하면 IP주소(3계층)에서 처리율 제한을 적용하는 것이 가능합니다.


- 처리율 제한을 회피하는 방법, 클라이언트를 어떻게 설계하는 것이 최선이가?
  - 클라이언트 측 캐시를 사용하여 API 호출 횟수를 줄인다.
  - 처리율 제한의 임계치를 이해하여, 짧은 시간동안 너무 많은 메시지를 보내지 않도록 한다.
  - 예외나 에러를 처리하는 코드를 도입하여 클라이언트가 예외적 상황으로부터 우아하게 복구될 수 있도록 한다.
  - 재시도 로직을 구현할 때는 충분한 백오프 시간을 둡니다.

<br/>

### 📖 Reference

---

[가상 면접 사례로 배우는 대규모 시스템 설계 기초](https://m.yes24.com/Goods/Detail/102819435)
